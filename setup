#!/bin/bash

user_array=(01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40)

#===================================================
function check_qemu_manage_type() {
echo
echo "========================="
echo ">>> qemu-arm-static 관리 방식 확인"

CHECK_FILE="/opt/md380-emu/qemu-arm-static"
if [[ ! -f "$CHECK_FILE" ]]; then
    echo ">>> /opt/md380-emu/qemu-arm-static 파일 없음. 이전 방식"
    qemu_manage_type=old
else
    echo ">>> /opt/md380-emu/qemu-arm-static 파일 있음. 새로운 방식"
    qemu_manage_type=new
fi
}

#===================================================
function check_qemu_version() {
	echo ">>> qemu-arm-static 버전 확인"
	if ! command -v qemu-arm-static > /dev/null 2>&1; then
        echo ">>> 명령 없음. qemu-arm-static 버전 확인 안됨"
        qemu_arm_ver=x  # 명령 없음. 확인 안됨
    fi

    # 버전 문자열 추출
    version_str=$(qemu-arm-static --version | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?' | head -n 1)

    if [ -z "$version_str" ]; then
        echo "빈문자열. qemu-arm-static 버전 확인 안됨"
        qemu_arm_ver=x  # 버전 파싱 실패. 확인 안됨
    fi

    # 기준 버전과 비교
    base_version="6.2.0"
    if dpkg --compare-versions "$version_str" le "$base_version"; then
		echo ">>> 버전 $version_str"
        qemu_arm_ver=SameOrLowerThan6.2.0  # 6.2.0 또는 이하
    else
        echo ">>> 버전 $version_str"
		qemu_arm_ver=HigherThan6.2.0   # 6.2.0 초과
    fi
}

#===================================================
function downgrade_qemu() {

# version 6.2.0보다 새로운 버전이므로 6.2.0으로 downgrade
# 아키텍쳐를 확인하여 그에 맞는 팩케지 다운로드
# 아키텍쳐 확인은 dpkg와 uname을 모두 사용

# 1. armhf / armv7l -> armhf.deb
# 2. arm64 / aarch64 -> arm64.deb
# 3. amd64 / x86_64 -> amd64.deb

# 순서는 아래와 같이
# 1. 관련 파일 백업
# 2. 관련 서비스 중단
# 3. 현재의 qemu 제거
# 4. 각각의 아키텍쳐에 맞는 QEMU 6.2 팩케지 설정
# 5. 다운로드 및 설치
# 6. 의존성 자동 해결
# 7. 자동 업그레이드 방지
# 8. 관련 파일 복원
# 9. 관련 서비스 재시작

#!/bin/bash

# 서비스 이름
SERVICE_NAME="md380-emu.service analog_bridge.service mmdvm_bridge.service"

# 등록한 추가사용자 확인 및 서비스 추가
user_array=(01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40)

for user in "${user_array[@]}"; do
	source /var/lib/dvswitch/dvs/var${user}.txt > /dev/null 2>&1
	if [ -e /var/lib/dvswitch/dvs/var${user}.txt ] && [ x${call_sign} != x ]; then
		SERVICE_NAME+=" md380-emu${user}.service"
		SERVICE_NAME+=" analog_bridge${user}.service"
		SERVICE_NAME+=" mmdvm_bridge${user}.service"
	fi
done

# 아키텍처 정보 확인
ARCH_DPKG=$(dpkg --print-architecture)  # 예: armhf, arm64, amd64
ARCH_UNAME=$(uname -m)                  # 예: armv7l, aarch64, x86_64

echo "dpkg 아키텍처: $ARCH_DPKG"
echo "uname 아키텍처: $ARCH_UNAME"

# Step 1. 관련 파일 백업
sudo mkdir -p /home/backup > /dev/null 2>&1
sudo cp /opt/md380-emu/md380-emu /home/backup/ > /dev/null 2>&1
sudo cp /opt/md380-emu/qemu-arm-static /home/backup/ > /dev/null 2>&1
sudo cp /lib/systemd/system/md380-emu.service /home/backup/ > /dev/null 2>&1

# Step 2. 관련 서비스 중단
# echo ">>> 서비스 중단: $SERVICE_NAME"
# sudo systemctl stop $SERVICE_NAME

# Step 3. 기존 QEMU 제거
echo ">>> 기존 qemu-user-static 제거"
sudo apt purge -y qemu-user-static
sudo apt autoremove -y

# Step 4. 아키텍처별 설치 파일 설정
echo ">>> architecture별 qemu 팩케지 준비"
QEMU_DEB_URL=""
if [[ "$ARCH_DPKG" == "armhf" || "$ARCH_UNAME" == "armv7l" ]]; then
    QEMU_DEB_URL="https://snapshot.debian.org/archive/debian/20220307T144557Z/pool/main/q/qemu/qemu-user-static_6.2+dfsg-2_armhf.deb"
elif [[ "$ARCH_DPKG" == "arm64" || "$ARCH_UNAME" == "aarch64" ]]; then
    QEMU_DEB_URL="https://snapshot.debian.org/archive/debian/20220307T144557Z/pool/main/q/qemu/qemu-user-static_6.2+dfsg-2_arm64.deb"
elif [[ "$ARCH_DPKG" == "amd64" || "$ARCH_UNAME" == "x86_64" ]]; then
    QEMU_DEB_URL="https://snapshot.debian.org/archive/debian/20220307T144557Z/pool/main/q/qemu/qemu-user-static_6.2+dfsg-2_amd64.deb"
else
    echo "지원되지 않는 아키텍처입니다: $ARCH_DPKG / $ARCH_UNAME"
    return 1
fi

# Step 5. QEMU 6.2 설치
echo ">>> QEMU 6.2 패키지 다운로드 및 설치"
cd /tmp
wget -O qemu-user-static.deb "$QEMU_DEB_URL" || { echo "다운로드 실패"; return 1; }
sudo dpkg -i qemu-user-static.deb

# Step 6. 의존성 자동 해결
echo ">>> 의존성 자동 해결"
sudo apt -f install -y

# Step 7. 자동 업그레이드 방지
echo ">>> qemu-user-static 자동 업그레이드 차단"
sudo apt-mark hold qemu-user-static

# Step 8. 관련 파일 복원
sudo cp /home/backup/md380-emu /opt/md380-emu/ > /dev/null 2>&1
sudo cp /home/backup/qemu-arm-static /opt/md380-emu/ > /dev/null 2>&1
sudo cp /home/backup/md380-emu.service /lib/systemd/system/ > /dev/null 2>&1
sudo rm -rf /home/backup > /dev/null 2>&1

# Step 9. 관련 서비스 재시작
sudo systemctl daemon-reload
sudo systemctl enable md380-emu
# echo ">>> 서비스 재시작: $SERVICE_NAME"
# sudo systemctl restart $SERVICE_NAME

# 확인
echo ">>> 설치된 QEMU 버전"
qemu-arm-static --version
echo ">>> 파일 확인"
ls /usr/bin/qemu-arm-static
}
#===================================================
function run_buster() {
	echo "========================="
	echo ">>> Running buster()"
	sudo apt update -y
	cd /tmp
	wget http://dvswitch.org/buster
	chmod +x buster
	sudo ./buster
	sudo apt-get install dvswitch-server -y
}
#===================================================
function run_bookworm() {
	echo "========================="
	echo ">>> Running bookworm()"
	sudo apt update -y
	cd /tmp
	wget http://dvswitch.org/bookworm
	chmod +x bookworm
	sudo ./bookworm
	sudo apt-get install dvswitch-server -y
}
#===================================================
function check_md380-emu_and_install() {
	echo
	echo "========================="
	echo ">>> check_md380-emu_and_install"
    # dvswitch-server의 설치 도중에 md380-emu 관련 파일의 설치가 누락되는 경우가 있으므로 아래와 확인 및 처리
    if [ ! -d "/opt/md380-emu" ] || [ ! -f /opt/md380-emu/md380-emu ]; then
        echo ">>> /opt/md380-emu/md380-emu 파일이 없으므로, md380-emu 추가 설치함"
        sudo apt-get install md380-emu
    else
        echo ">>> /opt/md380-emu/md380-emu 파일이 있으므로, md380-emu 추가 설치하지 않음"
    fi
}
#===================================================
function check_ARCHITECTURE() {
# dvswitch-server가 설치되지 않았다고 판별되었으므로
# 아키텍쳐를 확인하여 그에 맞게 팩케지 준비

# 1.   armhf이면 buster
# 2-1. arm64이고 debian 12이상이면 bookworm
# 2-2. arm64이고 debian 12 이상이 아니면 buster
# 3-1. amd64이고 버전이 22.04이상이면 bookworm
# 3-2. amd64이고 버전이 22.04이상이 아니면 buster

echo "========================="
echo ">>> architecture 확인"

# 아키텍처 정보
ARCH_DPKG=$(dpkg --print-architecture)   # 예: armhf, arm64, amd64
ARCH_UNAME=$(uname -m)                   # 예: armv7l, aarch64, x86_64

# 배포판 정보
source /etc/os-release
OS_ID=$ID              # 예: debian, ubuntu
OS_VERSION=$VERSION_ID # 예: "12", "22.04", "11"
MAJOR_VERSION=$(echo "$OS_VERSION" | cut -d. -f1)  # "22.04" → 22
#-------------------------
# 버전 비교 함수
version_ge() {
    dpkg --compare-versions "$1" ge "$2"
}
#-------------------------
# 아키텍처 및 배포판 기반 분기
if [[ "$ARCH_DPKG" == "armhf" || "$ARCH_UNAME" == "armv7l" ]]; then
    echo "32비트 ARM 시스템"
    return 0 #run_buster

elif [[ "$ARCH_DPKG" == "arm64" || "$ARCH_UNAME" == "aarch64" ]]; then
    echo "64비트 ARM 시스템"
	if [[ "$OS_ID" == "debian" || "$OS_ID" == "raspbian" ]]; then
    	if [ "$MAJOR_VERSION" -ge 12 ]; then
        	echo "debian 12 이상 - bookworm 설치"
		return 1 #run_bookworm
    	else
        	echo "debian 12 미만 - buster 설치"
		return 0 #run_buster
    	fi
	fi

elif [[ "$ARCH_DPKG" == "amd64" || "$ARCH_UNAME" == "x86_64" ]]; then
    echo "64비트 PC 시스템"
    if [[ "$OS_ID" == "ubuntu" ]] && version_ge "$OS_VERSION" "22.04"; then
	echo "ubuntu 22.04 이상 - bookworm 설치"
	return 1
    else
        echo "ubuntu 22.04 미만 - buster 설치"
	return 0
    fi
fi
}
#===================================================
function check_dvswitch() {
echo "========================="
echo ">>> dvswitch-server 의 설치가 되었는지 확인"
if dpkg -l | grep -q "^ii  dvswitch-server"; then
        dvswitch_already_installed=yes # yes
else
        dvswitch_already_installed=no # no
fi
}
#====== installation_apps =============================================
function installation_apps() {
echo
echo "========================="
echo ">>> multitail, htop 설치"
sudo apt-get install multitail -y

sudo apt install htop -y

# 대시보드: dvswitch의 bookworm 패케지에서 누락되어 있음
sudo apt-get install lighttpd -y

# replace temp.sh with a file for Korean
sudo wget -O /usr/local/dvs/temp.sh https://raw.githubusercontent.com/hl5btf/DVSwitch/main/temp.sh > /dev/null 2>&1
sudo chmod +x /usr/local/dvs/temp.sh
}

#====== set_path =============================================
function set_path() {
echo
echo "========================="
echo ">>> set path"
file="/etc/profile"

file="/var/lib/dvswitch/dvs/lan/language.txt"
if [ ! -f "$file" ]; then
    sudo cp /var/lib/dvswitch/dvs/lan/korean.txt $file
fi
# language.txt 가 없으면 아래 source에서 에러가 발생함

source /var/lib/dvswitch/dvs/var.txt > /dev/null 2>&1

# 추가할 디렉토리 목록
read -r -d '' new_dirs << 'EOF'
/opt/MMDVM_Bridge
/usr/local/dvs
EOF

# 1. 기존 PATH 라인들 모두 추출
existing_path_lines=$(grep -n '^export PATH=' "$file" | cut -d: -f1)

# 2. 기존 경로 모으기
existing_paths=""
for line_no in $existing_path_lines; do
    line=$(sed -n "${line_no}p" "$file")
    # $PATH:$dir1:$dir2 형식에서 실제 경로만 추출
    paths=$(echo "$line" | sed -E 's/^export PATH=\$PATH:?//; s/["]//g' | tr ':' '\n')
    for path in $paths; do
        existing_paths="$existing_paths"$'\n'"$path"
    done
done

# 3. 새로 추가할 디렉토리와 기존 경로들을 하나로 정리
all_paths="$existing_paths"
for dir in $new_dirs; do
    all_paths="$all_paths"$'\n'"$dir"
done

# 4. 중복 제거 + 다시 PATH 라인으로 조립
unique_paths=$(echo "$all_paths" | grep -v '^$' | sort -u | tr '\n' ':' | sed 's/:$//')
new_export_line="export PATH=\$PATH:$unique_paths"

# 5. 기존 PATH 라인 모두 삭제
if [ -n "$existing_path_lines" ]; then
    sudo sed -i '/^export PATH=/d' "$file"
fi

# 6. 새 export PATH 줄 추가
echo "$new_export_line" | sudo tee -a "$file" > /dev/null
}

#====== set_alias =============================================
function set_alias() {
echo
echo "========================="
echo ">>> set alias"
BASHRC="/etc/bash.bashrc"

# 추가할 alias 목록
read -r -d '' ALIASES << 'EOF'
alias dv="cd /usr/local/dvs"
alias data="cd /var/lib/dvswitch/dvs"
alias adv="cd /var/lib/dvswitch/dvs/adv"
alias user="cd /var/lib/dvswitch/dvs/adv"
alias lan="cd /var/lib/dvswitch/dvs/lan"
alias tgdb="cd /var/lib/dvswitch/dvs/tgdb"
alias ab="cd /opt/Analog_Bridge"
alias mb="cd /opt/MMDVM_Bridge"
alias ar="cd /opt/Analog_Reflector"
alias log="cd /var/log/dvswitch"
EOF

# 하나씩 확인하며, 기존에 없는 alias만 추가

while read -r line; do
    if ! grep -Fxq "$line" "$BASHRC"; then
        echo "$line" | sudo tee -a "$BASHRC" > /dev/null
    fi
done <<< "$ALIASES"
}

#====== set_reboot_default =============================================
function set_reboot_default() {
    echo
	echo "========================="
    echo ">>> set_reboot_default"

    FILE_CRON=/etc/crontab
    echo "#time=3" | sudo tee -a $FILE_CRON > /dev/null 2>&1
    echo "#reboot=yes" | sudo tee -a $FILE_CRON > /dev/null 2>&1
}

#====== copy_files_for_userXX =============================================
function copy_files_for_userXX() {
echo
echo "========================="
echo ">>> copy files for userXX"
files="analog_bridge00.service md380-emu00.service mmdvm_bridge00.service var00.txt"

dir=/var/lib/dvswitch/dvs
for file in $files; do
sudo wget -O ${dir}/$file https://raw.githubusercontent.com/hl5btf/DVSMU/main/$file > /dev/null 2>&1
sudo chmod +x ${dir}/$file
done

# /opt/md380-emu/qemu-arm-static 파일이 있으면, md380-emu00.service를 bookworm용으로 변경
CHECK_FILE="/opt/md380-emu/qemu-arm-static"
if [[ -f "$CHECK_FILE" ]]; then
	echo ">>> /opt/md380-emu 에 qemu-arm-static 파일이 있으므로 md380-emu00.service를 bookworm용으로 변경"
	sudo wget -O /var/lib/dvswitch/dvs/md380-emu00.service https://raw.githubusercontent.com/hl5btf/DVSMU/main/md380-emu00-bookworm.service > /dev/null 2>&1
	sudo chmod +x /var/lib/dvswitch/dvs/md380-emu00.service
fi

echo ">>> copy dvsm files for user00"

dir="/var/lib/dvswitch/dvs/adv/user00"
if [ ! -d "$dir" ]; then sudo mkdir -p "$dir"; fi

files="dvsm.adv dvsm.basic dvsm.macro dvsm.sh"
for file in $files; do
sudo wget -O ${dir}/$file https://raw.githubusercontent.com/hl5btf/DVSMU/main/$file > /dev/null 2>&1
sudo chmod +x ${dir}/$file
done


if [ ! -d "/var/lib/dvswitch/dvs/adv/user00EN" ]; then sudo mkdir -p "/var/lib/dvswitch/dvs/adv/user00EN"; fi
if [ ! -d "/var/lib/dvswitch/dvs/adv/user00KR" ]; then sudo mkdir -p "/var/lib/dvswitch/dvs/adv/user00KR"; fi

files="adv_audio.txt adv_dmr.txt adv_hotspot.txt adv_main.txt adv_managetg.txt adv_resetfvrt.txt adv_rxgain.txt adv_tgref.txt adv_tools.txt adv_txgain.txt"

for file in $files; do
sudo wget -O /var/lib/dvswitch/dvs/adv/user00EN/$file https://raw.githubusercontent.com/hl5btf/DVSMU/main/EN/$file > /dev/null 2>&1
sudo wget -O /var/lib/dvswitch/dvs/adv/user00KR/$file https://raw.githubusercontent.com/hl5btf/DVSMU/main/KR/$file > /dev/null 2>&1
done
}

#====== change_freq_of_all_users =============================================
function change_freq_of_all_users() {
echo
echo "========================="
echo ">>> change freq of all users"
# 주파수가 00000 일 경우에만, 430으로 수정

source /var/lib/dvswitch/dvs/var.txt > /dev/null 2>&1
    file=/var/lib/dvswitch/dvs/var.txt
    tag=rx_freq; value=430000000
    sudo sed -i -e "/^$tag=/ c $tag=$value" $file
    tag=tx_freq; value=430000000
    sudo sed -i -e "/^$tag=/ c $tag=$value" $file

source /var/lib/dvswitch/dvs/var00.txt > /dev/null 2>&1
    file=/var/lib/dvswitch/dvs/var00.txt
    tag=rx_freq; value=430000000
    sudo sed -i -e "/^$tag=/ c $tag=$value" $file
    tag=tx_freq; value=430000000
    sudo sed -i -e "/^$tag=/ c $tag=$value" $file

source /opt/MMDVM_Bridge/MMDVM_Bridge.ini > /dev/null 2>&1
    update_ini="sudo /opt/MMDVM_Bridge/dvswitch.sh updateINIFileValue"
        file=/opt/MMDVM_Bridge/MMDVM_Bridge.ini
        section=Info; tag=RXFrequency; value=430000000
        $update_ini $file $section $tag $value
        section=Info; tag=TXFrequency; value=430000000
        $update_ini $file $section $tag $value

for user in "${user_array[@]}"; do
source /var/lib/dvswitch/dvs/var${user}.txt > /dev/null 2>&1
if [ -e /var/lib/dvswitch/dvs/var${user}.txt ] && [ x${call_sign} != x ]; then
        update_ini="sudo /opt/user${user}/dvswitch.sh updateINIFileValue"    
        file=/var/lib/dvswitch/dvs/var${user}.txt
        tag=rx_freq; value=430000000
        sudo sed -i -e "/^$tag=/ c $tag=$value" $file
        tag=tx_freq; value=430000000
        sudo sed -i -e "/^$tag=/ c $tag=$value" $file

    source /opt/user${user}/MMDVM_Bridge.ini > /dev/null 2>&1
        file=/opt/user${user}/MMDVM_Bridge.ini
        section=Info; tag=RXFrequency; value=430000000
        $update_ini $file $section $tag $value
        section=Info; tag=TXFrequency; value=430000000
        $update_ini $file $section $tag $value
fi
done
}

#====== set_sudo_nopasswd =============================================
function set_sudo_nopasswd() {
echo
echo "========================="
echo ">>> set sudo nopasswd"
# === 일반 사용자만 sudo NOPASSWD로 추가 (메인 sudoers 수정, 중복 방지) ===

# 1) 일반 사용자(UID 1000~65533) 목록 가져오기
USERS=$(awk -F: '$3>=1000 && $3<65534 {print $1}' /etc/passwd)

#  사용자 계정을 찾지 못했다면
if [ -z "$USERS" ]; then
    return 1
fi

# 2) sudoers 백업
sudo cp /etc/sudoers /etc/sudoers.bak.$(date +%Y%m%d%H%M%S)

# 3) 추가할 사용자 중 이미 등록되지 않은 사용자만 필터링
NEED_ADD=""
for user in $USERS; do
    if sudo grep -q "^$user ALL=(ALL) NOPASSWD:ALL" /etc/sudoers; then
        : # $user 이미 sudoers에 등록됨 → 건너뜀
    else
        # $user 신규 추가
        NEED_ADD="$NEED_ADD$user"$'\n'
    fi
done

# 신규 추가 대상이 없으면 종료
if [ -z "$NEED_ADD" ]; then
    return 0
fi

# 4) 메인 sudoers에 추가할 내용 준비
TMPFILE=$(mktemp)
echo "# >>> Custom NOPASSWD users (자동 추가)" > "$TMPFILE" > /dev/null 2>&1
printf "%s" "$NEED_ADD" | while read -r u; do
    [ -n "$u" ] && echo "$u ALL=(ALL) NOPASSWD:ALL" >> "$TMPFILE" > /dev/null 2>&1
done
echo >> "$TMPFILE" > /dev/null 2>&1  # 마지막 빈줄

# 5) visudo를 이용해 안전하게 sudoers 업데이트
sudo bash -c "EDITOR='tee -a' visudo < '$TMPFILE'"

# 6) 임시파일 지우기
rm "$TMPFILE"

# sudo visudo 로 확인하면 내용이 반영되어 있음
}

#==================================================
# run_all_functions
#==================================================
function run_all_functions() {
# --- dvswitch-server가 설치되었는지 확인
check_dvswitch

# --- 설치되지 않았으면 장치의 아키텍쳐 확인 - 설치 준비
if [ "$dvswitch_already_installed" = "yes" ]; then
        echo ">>> dvswitch-server가 설치되어 있음."
	rtn2=999
elif [ "$dvswitch_already_installed" = "no" ]; then
        echo ">>> dvswitch-server가 설치되지 않았음."
        check_ARCHITECTURE
        rtn2=$?
fi
# --- 아키텍쳐에 맞게 dvswitch-server 설치
if [ "$rtn2" -eq 0 ]; then
        run_buster
elif [ "$rtn2" -eq 1 ]; then
        run_bookworm
fi

installation_apps
set_path
set_alias
set_reboot_default
copy_files_for_userXX
change_freq_of_all_users
set_sudo_nopasswd

# --- dvswitch-server의 설치 도중에 md380-emu 관련 파일의 설치가 누락되는 경우가 있으므로 확인 및 처리
check_md380-emu_and_install

# --- qemu-arm-static 관리 방식이 이전 방식 확인. /opt/md380-emu/qemu-arm-static 파일이 없으면 이전 방식.
check_qemu_manage_type

# --- qemu-arm-static 버전 확인
check_qemu_version

# --- qemu 관리방식이 이전방식이면서 qemu 버전이 6.2.0 보다 높으면, qemu를 6.2.0으로 downgrade
if [ "$qemu_manage_type" = "old" ] && [ "$qemu_arm_ver" = "HigherThan6.2.0" ]; then
		echo ">>> qemu 관리방식이 이전방식이면서 qemu 버전이 6.2.0 보다 높으므로 downgrade"
		downgrade_qemu
else
		echo ">>> qemu 관리가 새로운 방식이거나 버전이 6.2.0보다 높지 않으므로 qemu-arm-static 버전 변경하지 않음"
fi

#echo
#echo "========================="
#echo ">>> dvsmu_upgrade.sh"
#echo

#sudo wget https://raw.githubusercontent.com/hl5btf/DVSMU/main/dvsmu_upgrade.sh
#sudo chmod +x dvsmu_upgrade.sh
#sudo ./dvsmu_upgrade.sh
#sleep 1
#sudo rm dvsmu_upgrade.sh
}

#====== run_all_functions_with_progress_bar =============================================
function run_all_functions_with_progress_bar() {
(
run_all_functions
) > /dev/null 2>&1 &
pid=$!

echo
echo -n "약 5분 소요. 완료되면 리부팅합니다."
echo -e "\n"

while kill -0 $pid 2>/dev/null; do
    echo -n "#"
    sleep 1
done
}

#==================================================
# MAIN SCRIPT
#==================================================
if [[ "$1" == "show" || "$1" == "continue" ]]; then
	run_all_functions_with_progress_bar
else
	run_all_functions
fi

echo -e "\n"
echo "setup 설정이 완료되었습니다."
echo

if [[ "$1" == "continue" ]]; then exit 0; fi

echo "ENTER를 누르면 리부팅합니다."
echo
sleep 1
sudo rm setup
read
sudo reboot
exit 0

